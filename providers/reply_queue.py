import json
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional
from dateutil.parser import parse as parse_dt

from .utils import expand_possible_ids



class ReplyQueue:
    def __init__(self, path: Optional[Path] = None):
        self.path = path or Path("Summaries") / "reply_queue.json"
        self.path.parent.mkdir(parents=True, exist_ok=True)

    def _load(self) -> Dict:
        if self.path.exists():
            try:
                with self.path.open("r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, dict):
                        data.setdefault("drafts", [])
                        data["drafts"] = self._dedupe(data["drafts"])
                        return data
            except Exception:
                pass
        return {"drafts": []}

    def _dedupe(self, drafts: List[Dict]) -> List[Dict]:
        """Remove duplicate drafts by (contact_id, thread_id), keep newest."""
        latest = {}
        for d in drafts:
            if not isinstance(d, dict):
                continue
            contact_id = d.get("contact_id")
            thread_id = d.get("thread_id")
            if not contact_id or not thread_id:
                # Skip drafts without essential keys
                continue
            key = (contact_id, thread_id)
            ts = d.get("updated_at") or d.get("created_at")
            try:
                ts_parsed = parse_dt(ts) if ts else datetime.min.replace(tzinfo=timezone.utc)
            except Exception:
                ts_parsed = datetime.min.replace(tzinfo=timezone.utc)
            prev = latest.get(key)
            if not prev:
                latest[key] = d
                continue
            prev_ts = prev.get("updated_at") or prev.get("created_at") or ""
            try:
                prev_ts_parsed = parse_dt(prev_ts) if prev_ts else datetime.min.replace(tzinfo=timezone.utc)
            except Exception:
                prev_ts_parsed = datetime.min.replace(tzinfo=timezone.utc)
            if ts_parsed > prev_ts_parsed:
                latest[key] = d
        return list(latest.values())

    def _save(self, data: Dict):
        with self.path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def list_drafts(self, contact_id: Optional[str] = None, statuses: Optional[List[str]] = None) -> List[Dict]:
        queue = self._load()
        drafts = queue.get("drafts", [])
        if contact_id:
            possible = set(expand_possible_ids(contact_id))
            drafts = [d for d in drafts if d.get("contact_id") in possible]

        if statuses:
            statuses_lower = {s.lower() for s in statuses}
            drafts = [d for d in drafts if d.get("status", "").lower() in statuses_lower]
        drafts.sort(key=lambda d: d.get("created_at", ""), reverse=True)
        return drafts

    def get_draft(self, draft_id: str) -> Optional[Dict]:
        queue = self._load()
        for draft in queue.get("drafts", []):
            if draft.get("id") == draft_id:
                return draft
        return None

    def has_recent_draft(self, thread_id: str, last_message_ts: str, statuses: Optional[List[str]] = None, contact_id: Optional[str] = None) -> bool:
        queue = self._load()
        statuses_lower = {s.lower() for s in statuses} if statuses else None
        for draft in queue.get("drafts", []):
            if contact_id and draft.get("contact_id") != contact_id:
                continue
            if draft.get("thread_id") != thread_id:
                continue
            if last_message_ts and draft.get("last_message_ts") and draft["last_message_ts"] < last_message_ts:
                continue
            if statuses_lower and draft.get("status", "").lower() not in statuses_lower:
                continue
            return True
        return False

    def enqueue_draft(self, draft: Dict):
        """
        Add a new draft to the queue.
        Ensures no duplicates for the same (contact_id, thread_id) by keeping the latest draft.
        """
        queue = self._load()
        now = datetime.now(timezone.utc).isoformat()

        draft.setdefault("id", str(uuid.uuid4()))
        draft.setdefault("status", "pending_review")
        draft.setdefault("created_at", now)
        draft.setdefault("updated_at", now)
        draft.setdefault("history", [])
        draft["history"].append({
            "event": "created",
            "timestamp": now,
            "note": "Auto-generated by agent"
        })

        drafts = queue.setdefault("drafts", [])

        # Check if a draft for same contact + thread already exists
        existing = [
            d for d in drafts
            if d.get("contact_id") == draft.get("contact_id") and d.get("thread_id") == draft.get("thread_id")
        ]

        if existing:
            # Keep the one with latest timestamp (updated_at or created_at)
            for d in existing:
                prev_ts = d.get("updated_at") or d.get("created_at") or ""
                new_ts = draft.get("updated_at") or draft.get("created_at") or ""
                if new_ts > prev_ts:
                    # Replace the old draft
                    drafts.remove(d)
                else:
                    # If old draft is newer, skip adding the new one
                    print(f"[DraftQueue] ⚠️ Duplicate draft detected, skipping enqueue: {draft.get('id')}")
                    return

        drafts.append(draft)
        queue["drafts"] = self._dedupe(drafts)  # Optional double-safety
        self._save(queue)
        print(f"[DraftQueue] ✏️ Draft {draft['id']} enqueued successfully")


    def update_draft(self, draft_id: str, **fields) -> Optional[Dict]:
        queue = self._load()
        updated = None
        for draft in queue.get("drafts", []):
            if draft.get("id") == draft_id:
                for key, value in fields.items():
                    if key == "history" and isinstance(value, dict):
                        draft.setdefault("history", []).append(value)
                    else:
                        draft[key] = value
                draft["updated_at"] = datetime.now(timezone.utc).isoformat()
                updated = draft
                break
        if updated:
            self._save(queue)
        return updated

 