import json
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional



class ReplyQueue:
    def __init__(self, path: Optional[Path] = None):
        self.path = path or Path("Summaries") / "reply_queue.json"
        self.path.parent.mkdir(parents=True, exist_ok=True)

    def _load(self) -> Dict:
        if self.path.exists():
            try:
                with self.path.open("r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, dict):
                        data.setdefault("drafts", [])
                        data["drafts"] = self._dedupe(data["drafts"])
                        return data
            except Exception:
                pass
        return {"drafts": []}

    def _dedupe(self, drafts: List[Dict]) -> List[Dict]:
        """Remove duplicate drafts by (contact_id, thread_id), keep newest."""
        if not isinstance(drafts, list):
            return []
        latest = {}
        for d in drafts:
            if not isinstance(d, dict):
                continue
            key = (d.get("contact_id"), d.get("thread_id"))
            ts = d.get("updated_at") or d.get("created_at") or ""
            prev = latest.get(key)
            if not prev:
                latest[key] = d
                continue
            prev_ts = prev.get("updated_at") or prev.get("created_at") or ""
            if ts and ts > prev_ts:
                latest[key] = d
        return list(latest.values())

    def _save(self, data: Dict):
        with self.path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def list_drafts(self, contact_id: Optional[str] = None, statuses: Optional[List[str]] = None) -> List[Dict]:
        queue = self._load()
        drafts = queue.get("drafts", [])
        if contact_id:
            possible = set(expand_possible_ids(contact_id))
            drafts = [d for d in drafts if d.get("contact_id") in possible]

        if statuses:
            statuses_lower = {s.lower() for s in statuses}
            drafts = [d for d in drafts if d.get("status", "").lower() in statuses_lower]
        drafts.sort(key=lambda d: d.get("created_at", ""), reverse=True)
        return drafts

    def get_draft(self, draft_id: str) -> Optional[Dict]:
        queue = self._load()
        for draft in queue.get("drafts", []):
            if draft.get("id") == draft_id:
                return draft
        return None

    def has_recent_draft(self, thread_id: str, last_message_ts: str, statuses: Optional[List[str]] = None, contact_id: Optional[str] = None) -> bool:
        queue = self._load()
        statuses_lower = {s.lower() for s in statuses} if statuses else None
        for draft in queue.get("drafts", []):
            if contact_id and draft.get("contact_id") != contact_id:
                continue
            if draft.get("thread_id") != thread_id:
                continue
            if last_message_ts and draft.get("last_message_ts") and draft["last_message_ts"] < last_message_ts:
                continue
            if statuses_lower and draft.get("status", "").lower() not in statuses_lower:
                continue
            return True
        return False

    def enqueue_draft(self, draft: Dict):
        queue = self._load()
        now = datetime.now(timezone.utc).isoformat()
        draft.setdefault("id", str(uuid.uuid4()))
        draft.setdefault("status", "pending_review")
        draft.setdefault("created_at", now)
        draft.setdefault("updated_at", now)
        draft.setdefault("history", [])
        draft["history"].append({"event": "created", "timestamp": now, "note": "Auto-generated by agent"})
        drafts = queue.setdefault("drafts", [])

        # Remove existing draft for same contact + thread to avoid duplicates
        drafts = [d for d in drafts if not (
            d.get("contact_id") == draft.get("contact_id")
            and d.get("thread_id") == draft.get("thread_id")
        )]
        drafts.append(draft)
        queue["drafts"] = self._dedupe(drafts)
        self._save(queue)

    def update_draft(self, draft_id: str, **fields) -> Optional[Dict]:
        queue = self._load()
        updated = None
        for draft in queue.get("drafts", []):
            if draft.get("id") == draft_id:
                for key, value in fields.items():
                    if key == "history" and isinstance(value, dict):
                        draft.setdefault("history", []).append(value)
                    else:
                        draft[key] = value
                draft["updated_at"] = datetime.now(timezone.utc).isoformat()
                updated = draft
                break
        if updated:
            self._save(queue)
        return updated

    def remove_draft(self, draft_id: str):
        queue = self._load()
        original_len = len(queue.get("drafts", []))
        queue["drafts"] = [d for d in queue.get("drafts", []) if d.get("id") != draft_id]
        if len(queue["drafts"]) != original_len:
            self._save(queue)

